<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AR JRPG Battle</title>
    <script src="https://aframe.io/releases/1.2.0/aframe.min.js"></script>
    <script src="https://raw.githack.com/AR-js-org/AR.js/master/aframe/build/aframe-ar.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: Arial, sans-serif;
            overflow: hidden;
        }
        
        #battle-ui {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 15px;
            color: white;
            text-align: center;
            z-index: 1000;
        }
        
        .battle-buttons {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
        }
        
        button {
            padding: 10px 15px;
            font-size: 16px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            background: #4CAF50;
            color: white;
            transition: all 0.3s;
        }
        
        button:hover {
            background: #45a049;
            transform: scale(1.05);
        }
        
        button:disabled {
            background: #cccccc;
            cursor: not-allowed;
        }
        
        .hp-bar {
            width: 200px;
            height: 20px;
            background: #333;
            border-radius: 10px;
            margin: 5px auto;
            overflow: hidden;
        }
        
        .hp-fill {
            height: 100%;
            background: #4CAF50;
            transition: width 0.5s;
        }
        
        .enemy-hp .hp-fill {
            background: #f44336;
        }
        
        .battle-log {
            max-height: 100px;
            overflow-y: auto;
            font-size: 12px;
            margin-top: 10px;
        }
        
        #instructions {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 15px;
            border-radius: 10px;
            text-align: center;
            z-index: 1000;
        }

        #marker-status {
            position: fixed;
            top: 120px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 10px;
            border-radius: 8px;
            z-index: 1000;
        }

        a-scene {
    width: 100vw !important;
    height: 100vh !important;
    position: fixed !important;
    top: 0 !important;
    left: 0 !important;
}
    </style>
</head>
<body>
    <!-- AR –°—Ü–µ–Ω–∞ -->
    <a-scene 
        embedded 
        arjs="sourceType: webcam; debugUIEnabled: facingMode: environment; false; detectionMode: mono_and_matrix; matrixCodeType: 3x3;"
        renderer="logarithmicDepthBuffer: true;"
        vr-mode-ui="enabled: false">
        
        <!-- –ú–∞—Ä–∫–µ—Ä –†–æ–±–æ—Ç–∞ (qr1.png) -->
        <a-marker id="hero-marker" type="pattern" url="qr1.patt">
            <a-entity position="0 0.5 0">
                <a-plane id="hero-sprite"
                         width="1" 
                         height="1"
                         position="0 0 0"
                         material="src: #hero-texture; transparent: true; alphaTest: 0.5">
                </a-plane>
            </a-entity>
            <a-text value="–†–û–ë–û–¢" position="0 1.2 0" align="center" color="blue" scale="2 2 2"></a-text>
        </a-marker>
        
        <!-- –ú–∞—Ä–∫–µ—Ä –ó–æ–º–±–∏ (qr2.png) -->
        <a-marker id="enemy-marker" type="pattern" url="qr2.patt">
            <a-entity position="0 0.5 0">
                <a-plane id="enemy-sprite"
                         width="1" 
                         height="1"
                         position="0 0 0"
                         material="src: #enemy-texture; transparent: true; alphaTest: 0.5">
                </a-plane>
            </a-entity>
            <a-text value="–ó–û–ú–ë–ò" position="0 1.2 0" align="center" color="green" scale="2 2 2"></a-text>
        </a-marker>
        
        <a-entity camera></a-entity>
    </a-scene>
    
    <!-- –ò–Ω—Å—Ç—Ä—É–∫—Ü–∏–∏ -->
    <div id="instructions">
        <h3>üéÆ AR JRPG –ë–∏—Ç–≤–∞</h3>
        <p>–ù–∞–≤–µ–¥–∏—Ç–µ –∫–∞–º–µ—Ä—É –Ω–∞ –æ–±–∞ QR-–∫–æ–¥–∞ —á—Ç–æ–±—ã –Ω–∞—á–∞—Ç—å –±–æ–π!</p>
    </div>

    <div id="marker-status">
        <div>–†–æ–±–æ—Ç: <span id="hero-status">‚ùå –ù–µ –Ω–∞–π–¥–µ–Ω</span></div>
        <div>–ó–æ–º–±–∏: <span id="enemy-status">‚ùå –ù–µ –Ω–∞–π–¥–µ–Ω</span></div>
    </div>
    
    <!-- –ò–Ω—Ç–µ—Ä—Ñ–µ–π—Å –±–æ—è -->
    <div id="battle-ui" style="display: none;">
        <div class="hp-display">
            <div>–†–æ–±–æ—Ç: <span id="hero-hp">100</span>/100</div>
            <div class="hp-bar">
                <div id="hero-hp-bar" class="hp-fill" style="width: 100%"></div>
            </div>
            
            <div>–ó–æ–º–±–∏: <span id="enemy-hp">100</span>/100</div>
            <div class="hp-bar enemy-hp">
                <div id="enemy-hp-bar" class="hp-fill" style="width: 100%"></div>
            </div>
        </div>
        
        <div class="battle-buttons">
            <button onclick="battle.attack()" id="attack-btn">‚öîÔ∏è –ê—Ç–∞–∫–∞</button>
            <button onclick="battle.defend()" id="defend-btn">üõ°Ô∏è –ó–∞—â–∏—Ç–∞</button>
            <button onclick="battle.heal()" id="heal-btn">‚ù§Ô∏è –õ–µ—á–µ–Ω–∏–µ</button>
        </div>
        
        <div class="battle-log" id="battle-log">
            <!-- –õ–æ–≥ –±–∏—Ç–≤—ã –±—É–¥–µ—Ç –∑–¥–µ—Å—å -->
        </div>
    </div>

    <video id="video" width="300" height="300" autoplay></video>
<script>
navigator.mediaDevices.getUserMedia({video: true})
    .then(stream => {
        document.getElementById('video').srcObject = stream;
    })
    .catch(err => {
        alert('–û—à–∏–±–∫–∞ –∫–∞–º–µ—Ä—ã: ' + err.message);
    });
</script>

    <!-- –¢–µ–∫—Å—Ç—É—Ä—ã –¥–ª—è —Å–ø—Ä–∞–π—Ç–æ–≤ -->
    <script>
        // –°–æ–∑–¥–∞–µ–º —Ç–µ–∫—Å—Ç—É—Ä—ã –∏–∑ –≤–∞—à–∏—Ö —Å–ø—Ä–∞–π—Ç–æ–≤
        async function createSpriteTexture(imagePaths, defaultColor) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            
            // –†–∞–∑–º–µ—Ä—ã —Å–ø—Ä–∞–π—Ç-–ª–∏—Å—Ç–∞
            const frameWidth = 100;
            const frameHeight = 100;
            const cols = 4;
            
            try {
                // –ó–∞–≥—Ä—É–∂–∞–µ–º –ø–µ—Ä–≤–æ–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –¥–ª—è –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è —Ä–∞–∑–º–µ—Ä–æ–≤
                const firstImage = await loadImage(imagePaths[0]);
                const actualFrameWidth = firstImage.width;
                const actualFrameHeight = firstImage.height;
                
                const rows = Math.ceil(imagePaths.length / cols);
                canvas.width = cols * actualFrameWidth;
                canvas.height = rows * actualFrameHeight;
                
                // –û—á–∏—â–∞–µ–º canvas
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                // –ó–∞–≥—Ä—É–∂–∞–µ–º –∏ —Ä–∏—Å—É–µ–º –≤—Å–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è
                for (let i = 0; i < imagePaths.length; i++) {
                    const img = await loadImage(imagePaths[i]);
                    const col = i % cols;
                    const row = Math.floor(i / cols);
                    const x = col * actualFrameWidth;
                    const y = row * actualFrameHeight;
                    
                    ctx.drawImage(img, x, y, actualFrameWidth, actualFrameHeight);
                }
                
                console.log(`–°–ø—Ä–∞–π—Ç-–ª–∏—Å—Ç —Å–æ–∑–¥–∞–Ω: ${imagePaths.length} –∫–∞–¥—Ä–æ–≤`);
                return new THREE.CanvasTexture(canvas);
                
            } catch (error) {
                console.error('–û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è —Ç–µ–∫—Å—Ç—É—Ä—ã:', error);
                // Fallback - –ø—Ä–æ—Å—Ç–∞—è —Ü–≤–µ—Ç–Ω–∞—è —Ç–µ–∫—Å—Ç—É—Ä–∞
                canvas.width = 100;
                canvas.height = 100;
                ctx.fillStyle = defaultColor;
                ctx.fillRect(0, 0, 100, 100);
                return new THREE.CanvasTexture(canvas);
            }
        }

        function loadImage(src) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.onload = () => resolve(img);
                img.onerror = () => reject(new Error(`–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å: ${src}`));
                img.src = src;
            });
        }

        // –°–æ–∑–¥–∞–µ–º —Ç–µ–∫—Å—Ç—É—Ä—ã –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ —Å—Ç—Ä–∞–Ω–∏—Ü—ã
        document.addEventListener('DOMContentLoaded', async function() {
            try {
                // –°–æ–∑–¥–∞–µ–º –ø—É—Ç–∏ –∫ —Å–ø—Ä–∞–π—Ç–∞–º —Ä–æ–±–æ—Ç–∞
                const robotPaths = [];
                for (let i = 1; i <= 10; i++) {
                    robotPaths.push(`robot/Idle (${i}).png`);
                }

                // –°–æ–∑–¥–∞–µ–º –ø—É—Ç–∏ –∫ —Å–ø—Ä–∞–π—Ç–∞–º –∑–æ–º–±–∏
                const zombiePaths = [];
                for (let i = 1; i <= 15; i++) {
                    zombiePaths.push(`zombie/Idle (${i}).png`);
                }

                // –°–æ–∑–¥–∞–µ–º —Ç–µ–∫—Å—Ç—É—Ä—ã
                const heroTexture = await createSpriteTexture(robotPaths, '#3498db');
                const enemyTexture = await createSpriteTexture(zombiePaths, '#e74c3c');

                // –î–æ–±–∞–≤–ª—è–µ–º —Ç–µ–∫—Å—Ç—É—Ä—ã –≤ —Å—Ü–µ–Ω—É
                const scene = document.querySelector('a-scene');
                scene.addEventListener('loaded', function() {
                    const heroPlane = document.getElementById('hero-sprite');
                    const enemyPlane = document.getElementById('enemy-sprite');
                    
                    if (heroPlane && heroPlane.object3D) {
                        heroPlane.object3D.children[0].material.map = heroTexture;
                        heroPlane.object3D.children[0].material.needsUpdate = true;
                    }
                    
                    if (enemyPlane && enemyPlane.object3D) {
                        enemyPlane.object3D.children[0].material.map = enemyTexture;
                        enemyPlane.object3D.children[0].material.needsUpdate = true;
                    }
                });

            } catch (error) {
                console.error('–û—à–∏–±–∫–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ —Ç–µ–∫—Å—Ç—É—Ä:', error);
            }
        });
    </script>
    
    <!-- –õ–æ–≥–∏–∫–∞ –∏–≥—Ä—ã -->
    <script>
        class BattleSystem {
            constructor() {
                this.heroHP = 100;
                this.enemyHP = 100;
                this.isBattleActive = false;
                this.isPlayerTurn = true;
                this.heroDefending = false;
            }
            
            attack() {
                if (!this.isPlayerTurn || !this.isBattleActive) return;
                
                const damage = Math.floor(Math.random() * 20) + 10;
                this.enemyHP = Math.max(0, this.enemyHP - damage);
                this.addToLog(`‚öîÔ∏è –†–æ–±–æ—Ç –∞—Ç–∞–∫—É–µ—Ç –∏ –Ω–∞–Ω–æ—Å–∏—Ç ${damage} —É—Ä–æ–Ω–∞!`);
                this.updateUI();
                this.endPlayerTurn();
            }
            
            defend() {
                if (!this.isPlayerTurn || !this.isBattleActive) return;
                
                this.heroDefending = true;
                this.addToLog(`üõ°Ô∏è –†–æ–±–æ—Ç –∑–∞—â–∏—â–∞–µ—Ç—Å—è! –°–ª–µ–¥—É—é—â–∞—è –∞—Ç–∞–∫–∞ –±—É–¥–µ—Ç —Å–ª–∞–±–µ–µ.`);
                this.endPlayerTurn();
            }
            
            heal() {
                if (!this.isPlayerTurn || !this.isBattleActive) return;
                
                const healAmount = Math.floor(Math.random() * 15) + 10;
                this.heroHP = Math.min(100, this.heroHP + healAmount);
                this.addToLog(`‚ù§Ô∏è –†–æ–±–æ—Ç –ª–µ—á–∏—Ç—Å—è –Ω–∞ ${healAmount} HP!`);
                this.updateUI();
                this.endPlayerTurn();
            }
            
            endPlayerTurn() {
                this.isPlayerTurn = false;
                this.disableButtons();
                
                // –•–æ–¥ –≤—Ä–∞–≥–∞ —á–µ—Ä–µ–∑ —Å–µ–∫—É–Ω–¥—É
                setTimeout(() => this.enemyTurn(), 1000);
            }
            
            enemyTurn() {
                if (!this.isBattleActive) return;
                
                const enemyAction = Math.random();
                let enemyDamageReduction = this.heroDefending ? 0.5 : 1;
                
                if (enemyAction < 0.6) {
                    // –í—Ä–∞–≥ –∞—Ç–∞–∫—É–µ—Ç
                    const damage = Math.floor((Math.random() * 15 + 5) * enemyDamageReduction);
                    this.heroHP = Math.max(0, this.heroHP - damage);
                    this.addToLog(`üëπ –ó–æ–º–±–∏ –∞—Ç–∞–∫—É–µ—Ç –∏ –Ω–∞–Ω–æ—Å–∏—Ç ${damage} —É—Ä–æ–Ω–∞!`);
                } else if (enemyAction < 0.8) {
                    // –í—Ä–∞–≥ –∑–∞—â–∏—â–∞–µ—Ç—Å—è
                    this.addToLog(`üëπ –ó–æ–º–±–∏ –∑–∞—â–∏—â–∞–µ—Ç—Å—è!`);
                } else {
                    // –í—Ä–∞–≥ –ª–µ—á–∏—Ç—Å—è
                    const healAmount = Math.floor(Math.random() * 10) + 5;
                    this.enemyHP = Math.min(100, this.enemyHP + healAmount);
                    this.addToLog(`üëπ –ó–æ–º–±–∏ –ª–µ—á–∏—Ç—Å—è –Ω–∞ ${healAmount} HP!`);
                }
                
                this.heroDefending = false;
                this.updateUI();
                this.checkBattleEnd();
                
                if (this.isBattleActive) {
                    this.isPlayerTurn = true;
                    this.enableButtons();
                }
            }
            
            updateUI() {
                document.getElementById('hero-hp').textContent = this.heroHP;
                document.getElementById('enemy-hp').textContent = this.enemyHP;
                document.getElementById('hero-hp-bar').style.width = this.heroHP + '%';
                document.getElementById('enemy-hp-bar').style.width = this.enemyHP + '%';
            }
            
            addToLog(message) {
                const log = document.getElementById('battle-log');
                const entry = document.createElement('div');
                entry.textContent = message;
                log.appendChild(entry);
                log.scrollTop = log.scrollHeight;
            }
            
            disableButtons() {
                document.getElementById('attack-btn').disabled = true;
                document.getElementById('defend-btn').disabled = true;
                document.getElementById('heal-btn').disabled = true;
            }
            
            enableButtons() {
                document.getElementById('attack-btn').disabled = false;
                document.getElementById('defend-btn').disabled = false;
                document.getElementById('heal-btn').disabled = false;
            }
            
            checkBattleEnd() {
                if (this.heroHP <= 0) {
                    this.isBattleActive = false;
                    this.addToLog('üíÄ –†–æ–±–æ—Ç –ø–æ–±–µ–∂–¥–µ–Ω! –ò–≥—Ä–∞ –æ–∫–æ–Ω—á–µ–Ω–∞.');
                    this.disableButtons();
                } else if (this.enemyHP <= 0) {
                    this.isBattleActive = false;
                    this.addToLog('üéâ –ó–æ–º–±–∏ –ø–æ–±–µ–∂–¥–µ–Ω! –ü–æ–±–µ–¥–∞!');
                    this.disableButtons();
                }
            }
            
            startBattle() {
                if (this.isBattleActive) return;
                
                this.heroHP = 100;
                this.enemyHP = 100;
                this.isBattleActive = true;
                this.isPlayerTurn = true;
                this.heroDefending = false;
                
                document.getElementById('battle-ui').style.display = 'block';
                document.getElementById('battle-log').innerHTML = '';
                this.addToLog('‚öîÔ∏è –ë–∏—Ç–≤–∞ –Ω–∞—á–∞–ª–∞—Å—å! –†–æ–±–æ—Ç vs –ó–æ–º–±–∏!');
                this.updateUI();
                this.enableButtons();
            }
        }
        
        const battle = new BattleSystem();
        
        // –û—Ç—Å–ª–µ–∂–∏–≤–∞–µ–º –º–∞—Ä–∫–µ—Ä—ã
        let heroFound = false;
        let enemyFound = false;
        
        document.addEventListener('DOMContentLoaded', function() {
            const scene = document.querySelector('a-scene');
            
            scene.addEventListener('markerFound', function(e) {
                if (e.target.id === 'hero-marker') {
                    heroFound = true;
                    document.getElementById('hero-status').textContent = '‚úÖ –ù–∞–π–¥–µ–Ω';
                    document.getElementById('hero-status').style.color = 'green';
                } else if (e.target.id === 'enemy-marker') {
                    enemyFound = true;
                    document.getElementById('enemy-status').textContent = '‚úÖ –ù–∞–π–¥–µ–Ω';
                    document.getElementById('enemy-status').style.color = 'green';
                }
                
                if (heroFound && enemyFound && !battle.isBattleActive) {
                    battle.startBattle();
                }
            });
            
            scene.addEventListener('markerLost', function(e) {
                if (e.target.id === 'hero-marker') {
                    heroFound = false;
                    document.getElementById('hero-status').textContent = '‚ùå –ù–µ –Ω–∞–π–¥–µ–Ω';
                    document.getElementById('hero-status').style.color = 'red';
                } else if (e.target.id === 'enemy-marker') {
                    enemyFound = false;
                    document.getElementById('enemy-status').textContent = '‚ùå –ù–µ –Ω–∞–π–¥–µ–Ω';
                    document.getElementById('enemy-status').style.color = 'red';
                }
            });
        });
    </script>
</body>
</html>